//==================================================================================
//==================================================================================
// File: HardwareAndCo.cpp
// Description: Centralized initialization and management of OSCAR_P01A01
//              hardware resources and software components (TFT display, GUI,
//              DSP modules, etc.)
//
// Copyright (c) 2025 Dad Design.
//==================================================================================
//==================================================================================

#include "HardwareAndCo.h"
#include "EffectsConfig.h"
#include "Sections.h"

//**********************************************************************************
// External handles (generated by CubeMX)
//**********************************************************************************
extern QSPI_HandleTypeDef hqspi;               // QSPI flash interface handle
extern SAI_HandleTypeDef  hsai_BlockA1;        // SAI block A1 for audio
extern SAI_HandleTypeDef  hsai_BlockB1;        // SAI block B1 for audio
extern DMA_HandleTypeDef  hdma_sai1_a;         // DMA for SAI A
extern DMA_HandleTypeDef  hdma_sai1_b;         // DMA for SAI B
extern SPI_HandleTypeDef  hspi1;               // SPI for display
extern DMA_HandleTypeDef  hdma_spi1_tx;        // DMA for SPI transmit
extern TIM_HandleTypeDef  htim6;               // Timer for SoftSPI
extern UART_HandleTypeDef huart1;              // UART for MIDI
extern DMA_HandleTypeDef  hdma_usart1_rx;      // DMA for UART receive

//**********************************************************************************
// Global instances
//**********************************************************************************

// Flash memory instance
DadDrivers::cW25Q128 __Flash;

// Persistent storage instances
QFLASH_FLASHER  DadPersistentStorage::cFlasherStorage __FlasherStorage;
QFLASH_TABSAVE  DadPersistentStorage::sSaveBlock      __TabSaveBlock[BLOCK_STORAGE_MEM_SIZE/QFLAH_SECTOR_SIZE];
DadPersistentStorage::cBlockStorageManager            __BlockStorageManager(__TabSaveBlock);

// Display instance
DECLARE_DISPLAY(__Display);

// Monitor instances (conditional compilation)
#ifdef MONITOR
DadUtilities::cMonitor __Monitor;
volatile float CPULoad;     // CPU load percentage
volatile float EffectTime;  // Effect processing time in microseconds
volatile float Frequency;   // Operating frequency in Hz
#endif

// Switch instances
DadDrivers::cSwitch __Switch1;
DadDrivers::cSwitch __Switch2;

// Encoder instances
DadDrivers::cEncoder __Encoder1;
DadDrivers::cEncoder __Encoder2;
DadDrivers::cEncoder __Encoder3;
DadDrivers::cEncoder __Encoder0;

// SoftSPI instance
DadDrivers::cSoftSPI __SoftSPI;

// Dry/Wet instance
DadDrivers::cDryWet  __DryWet;

// MIDI interface instance
DadDrivers::cMidi __Midi;

// GUI instance
DadGUI::cMainGUI __GUI;

// Effect instance
DECLARE_EFFECT;

// =============================================================================
// Timer callback (drives periodic software SPI updates)
// =============================================================================

//**********************************************************************************
// HAL_TIM_PeriodElapsedCallback
// Timer interrupt callback for SoftSPI updates
//**********************************************************************************
ITCM void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM6) {
        __SoftSPI.TimerCallback();  // Update SoftSPI state
    }
}

// =============================================================================
// MIDI USB Wrappers and FIFO Implementation
// =============================================================================

//**********************************************************************************
// MIDI FIFO Configuration
//**********************************************************************************

// Size of MIDI event FIFO buffer
#define MIDI_FIFO_SIZE 20

// MIDI command types
typedef enum {
    MIDI_EVENT_NOTE_ON,   // Note on event
    MIDI_EVENT_NOTE_OFF,  // Note off event
    MIDI_EVENT_CC,        // Control change event
    MIDI_EVENT_PC         // Program change event
} MidiCMD_t;

// MIDI event structure
typedef struct {
    MidiCMD_t type;       // Event type
    uint8_t data[3];      // Channel, Note/Control/Program, Velocity/Value
} MidiEvent_t;

// FIFO buffer and management variables
static MidiEvent_t midiFifoBuffer[MIDI_FIFO_SIZE];        // FIFO buffer
static volatile uint16_t midiFifoHead = 0;                // Head index
static volatile uint16_t midiFifoTail = 0;                // Tail index
static volatile uint16_t midiFifoCount = 0;               // Number of events in FIFO

// -----------------------------------------------------------------------------
// MIDI FIFO Management Functions
// -----------------------------------------------------------------------------

//**********************************************************************************
// MidiFifoPush
// Add MIDI event to FIFO buffer (thread-safe)
//**********************************************************************************
ITCM static bool MidiFifoPush(const MidiEvent_t* event) {
    uint16_t nextHead = (midiFifoHead + 1) % MIDI_FIFO_SIZE;
    if (nextHead == midiFifoTail) {
        return false; // FIFO full
    }
    midiFifoBuffer[midiFifoHead] = *event;
    midiFifoHead = nextHead;
    midiFifoCount++;
    return true;
}

//**********************************************************************************
// MidiFifoPop
// Remove MIDI event from FIFO buffer
//**********************************************************************************
static bool MidiFifoPop(MidiEvent_t* event) {
    if (midiFifoCount == 0) {
        return false; // FIFO empty
    }
    *event = midiFifoBuffer[midiFifoTail];
    midiFifoTail = (midiFifoTail + 1) % MIDI_FIFO_SIZE;
    midiFifoCount--;
    return true;
}

// =============================================================================
// MIDI USB Wrapper Functions
// =============================================================================

//**********************************************************************************
// OnNoteOn
// Handle note on events from USB MIDI
//**********************************************************************************
ITCM void OnNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {
    MidiEvent_t event;
    event.type = MIDI_EVENT_NOTE_ON;
    event.data[0] = channel;
    event.data[1] = note;
    event.data[2] = velocity;
    MidiFifoPush(&event); // Add event to FIFO
}

//**********************************************************************************
// OnNoteOff
// Handle note off events from USB MIDI
//**********************************************************************************
ITCM void OnNoteOff(uint8_t channel, uint8_t note, uint8_t velocity) {
    MidiEvent_t event;
    event.type = MIDI_EVENT_NOTE_OFF;
    event.data[0] = channel;
    event.data[1] = note;
    event.data[2] = velocity;
    MidiFifoPush(&event); // Add event to FIFO
}

//**********************************************************************************
// OnControlChange
// Handle control change events from USB MIDI
//**********************************************************************************
ITCM void OnControlChange(uint8_t channel, uint8_t control, uint8_t value) {
    MidiEvent_t event;
    event.type = MIDI_EVENT_CC;
    event.data[0] = channel;
    event.data[1] = control;
    event.data[2] = value;
    MidiFifoPush(&event); // Add event to FIFO
}

//**********************************************************************************
// OnProgramChange
// Handle program change events from USB MIDI
//**********************************************************************************
ITCM void OnProgramChange(uint8_t channel, uint8_t program) {
    MidiEvent_t event;
    event.type = MIDI_EVENT_PC;
    event.data[0] = channel;
    event.data[1] = program;
    event.data[2] = 0; // Unused value
    MidiFifoPush(&event); // Add event to FIFO
}

// =============================================================================
// MIDI FIFO Processing
// =============================================================================

//**********************************************************************************
// ProcessMidiFifo
// Process all pending MIDI events from the FIFO
//**********************************************************************************
void ProcessMidiFifo(void) {
    MidiEvent_t event;

    // Safely pop event from FIFO with interrupts disabled
    __disable_irq();
    bool IsNotEmpty = MidiFifoPop(&event);
    __enable_irq();

    // Process all events in FIFO
    while (IsNotEmpty) {
        switch (event.type) {
            case MIDI_EVENT_NOTE_ON:
                __Midi.OnNoteOn(event.data[0], event.data[1], event.data[2]);
                break;
            case MIDI_EVENT_NOTE_OFF:
                __Midi.OnNoteOff(event.data[0], event.data[1], event.data[2]);
                break;
            case MIDI_EVENT_CC:
                __Midi.OnControlChange(event.data[0], event.data[1], event.data[2]);
                break;
            case MIDI_EVENT_PC:
                __Midi.OnProgramChange(event.data[0], event.data[1]);
                break;
        }

        // Get next event with interrupts disabled
        __disable_irq();
        IsNotEmpty = MidiFifoPop(&event);
        __enable_irq();
    }
}

// =============================================================================
// Hardware Initialization
// =============================================================================

// Background layer declaration for display
DECLARE_LAYER(BackLayer, SCREEN_WIDTH, SCREEN_HEIGHT);

//**********************************************************************************
// HardwareAndCoInitialize
// Initializes all hardware peripherals in the correct order
//**********************************************************************************
void HardwareAndCoInitialize() {

    // Initialize SDRAM memory
    SDRAM_Initialize();

    // Initialize QSPI flash memory
    if (HAL_OK != __Flash.Init(&hqspi, DOUBLE_MODE, FLASH_ADDRESS)) {
        Error_Handler();
    }

    // Configure Memory Protection Unit
    MPU_Config();

    // Invalidate CPU caches for memory consistency
    SCB_InvalidateDCache();
    SCB_InvalidateICache();

    // Initialize system monitor (conditional)
#ifdef MONITOR
    __Monitor.Init();
#endif

    // Initialize persistent storage and check if initialization is needed
    bool NeedInitBlockStorage = __BlockStorageManager.Init(EFFECT_BUILD);

    // Initialize display
    INIT_DISPLAY(__Display, &hspi1);
    __Display.setOrientation(Rotation::Degre_90);

    // Initialize GUI system
    __GUI.Initialize();

    // Load and display splash screen from flash
    uint8_t* ImgPtr;
    uint8_t  NbFrame;
    uint16_t Width;
    uint16_t Height;
    __FlasherStorage.GetImgInformation(EFFECT_SPLATCH_SCREEN, ImgPtr, NbFrame, Width, Height);
    DadGFX::cImageLayer* SplatchLayer = nullptr;

    if(ImgPtr){
        SplatchLayer = __Display.addLayer(ImgPtr, 0, 0, Width, Height, 1, NbFrame);
        SplatchLayer->changeZOrder(2);
    }

    // Create background layer for initialization messages
    DadGFX::cLayer* BackLayer = ADD_LAYER(__Display, BackLayer, 0, 0, 2);
    BackLayer->changeZOrder(3);
    BackLayer->eraseLayer();
    __Display.flush();

    // Display initialization message if storage needs initialization
    if(NeedInitBlockStorage){
        constexpr uint16_t WidthBox = 200;
        constexpr uint16_t HeightBox = 120;
        constexpr uint16_t xBox = (SCREEN_WIDTH - WidthBox ) / 2;
        constexpr uint16_t yBox = (SCREEN_HEIGHT - HeightBox) / 2;
        constexpr uint16_t xHalfBox = SCREEN_WIDTH / 2;
        constexpr uint16_t yHalfBox = SCREEN_HEIGHT / 2;
        constexpr uint16_t yOffset = 50;

        const char* Text1 = "Please wait...";
        const char* Text2 = "Initializing";
        const char* Text3 = "flash memory.";

        // Draw initialization dialog box
        BackLayer->drawFillRect(xBox, yBox, WidthBox, HeightBox, DadGUI::__pActivePalette->SplatchBack);

        // Display initialization text
        BackLayer->setFont(FONTMB);
        uint16_t TextWidth = BackLayer->getTextWidth(Text1);
        BackLayer->setCursor(xHalfBox - TextWidth/2, yHalfBox - yOffset);
        BackLayer->setTextFrontColor(DadGUI::__pActivePalette->SplatchText);
        BackLayer->drawText(Text1);

        BackLayer->setFont(FONTS);
        TextWidth = BackLayer->getTextWidth(Text2);
        BackLayer->setCursor(xHalfBox - TextWidth/2, yHalfBox);
        BackLayer->setTextFrontColor(DadGUI::__pActivePalette->SplatchText);
        BackLayer->drawText(Text2);

        TextWidth = BackLayer->getTextWidth(Text3);
        BackLayer->setCursor(xHalfBox - TextWidth/2, yHalfBox + 20);
        BackLayer->setTextFrontColor(DadGUI::__pActivePalette->SplatchText);
        BackLayer->drawText(Text3);

        __Display.flush();

        // Initialize flash memory storage
        __BlockStorageManager.InitializeMemory(EFFECT_BUILD);
        HAL_Delay(400);
    } else {
        __Display.flush();
        HAL_Delay(1000);
    }

    // Clean up initialization layers
    BackLayer->changeZOrder(0);
    if(SplatchLayer){
        SplatchLayer->changeZOrder(0);
    }

    // Initialize foot switches with debouncing parameters
    constexpr uint32_t kUpdateTime      = static_cast<uint32_t>(RT_RATE * 0.02f);   // 20ms debounce
    constexpr uint32_t kMinPeriod       = static_cast<uint32_t>(RT_RATE * 0.15f);   // 150ms min valid press
    constexpr uint32_t kMaxPeriod       = static_cast<uint32_t>(RT_RATE * 1.1f);    // 1.1s max hold
    constexpr uint32_t kAbortMaxPeriod  = static_cast<uint32_t>(RT_RATE * 1.5f);    // 1.5s timeout

    __Switch1.Init(FootSwitch1A_GPIO_Port, FootSwitch1A_Pin,
                   RT_RATE, kUpdateTime, kMinPeriod, kMaxPeriod, kAbortMaxPeriod);

    __Switch2.Init(FootSwitch2A_GPIO_Port, FootSwitch2A_Pin,
                   RT_RATE, kUpdateTime, kMinPeriod, kMaxPeriod, kAbortMaxPeriod);

    // Initialize rotary encoders
    constexpr uint32_t EncoderUpdatePeriodMs = RT_RATE * 0.001f; // 1ms update
    constexpr uint32_t SwitchUpdatePeriodMs  = RT_RATE * 0.005f; // 5ms switch check

    __Encoder3.Init(Encoder1_A_GPIO_Port, Encoder1_A_Pin,
                    Encoder1_B_GPIO_Port, Encoder1_B_Pin,
                    Encoder1_SW_GPIO_Port, Encoder1_SW_Pin,
                    EncoderUpdatePeriodMs, SwitchUpdatePeriodMs);

    __Encoder2.Init(Encoder2_A_GPIO_Port, Encoder2_A_Pin,
                    Encoder2_B_GPIO_Port, Encoder2_B_Pin,
                    Encoder2_SW_GPIO_Port, Encoder2_SW_Pin,
                    EncoderUpdatePeriodMs, SwitchUpdatePeriodMs);

    __Encoder1.Init(Encoder3_A_GPIO_Port, Encoder3_A_Pin,
                    Encoder3_B_GPIO_Port, Encoder3_B_Pin,
                    Encoder3_SW_GPIO_Port, Encoder3_SW_Pin,
                    EncoderUpdatePeriodMs, SwitchUpdatePeriodMs);

    __Encoder0.Init(Encoder0_A_GPIO_Port, Encoder0_A_Pin,
                    Encoder0_B_GPIO_Port, Encoder0_B_Pin,
                    Encoder0_SW_GPIO_Port, Encoder0_SW_Pin,
                    EncoderUpdatePeriodMs, SwitchUpdatePeriodMs);

    // Initialize software SPI for external peripherals
    __SoftSPI.Initialize(SSPI_DATA_GPIO_Port, SSPI_DATA_Pin,
                         SSPI_CLK_GPIO_Port, SSPI_CLK_Pin,
                         SSPI_CS_GPIO_Port, SSPI_CS_Pin,
                         &htim6);

    // Initialize MIDI interface
    HAL_TIM_Base_Start_IT(&htim6); // Enable periodic SoftSPI callback
    __Midi.Initialize(&huart1, 0);

    __DryWet.Init(MIN_DRY, MAX_DRY, 1 / (FAD_TIME * SAMPLING_RATE));
    __DryWet.forceMix(0.0f);

    // Initialize audio effect processing
    __Effect.Initialize();

    // Start GUI system
    __GUI.Start();

    // Start audio processing engine
    if (HAL_OK != StartAudio(&hsai_BlockA1, &hsai_BlockB1)) {
        Error_Handler();
    }
}

// =============================================================================
// Real-time Audio Processing
// =============================================================================

// System state variables
eOnOff __OnOffCmd  = eOnOff::ByPass; // Pending state change command
eOnOff __MemOnOff  = eOnOff::ByPass; // Current audio processing state
uint32_t __CT = 0;                   // Activity counter for LED heartbeat

//**********************************************************************************
// AudioCallback
// Real-time audio processing function executed by the audio engine
//**********************************************************************************
ITCM void AudioCallback(AudioBuffer *pIn, AudioBuffer *pOut) {

#ifdef MONITOR
    __Monitor.startMonitoring(); // Start performance monitoring
#endif

    // Update activity counter for LED heartbeat
    __CT++;

    // Update all input devices in real-time
    __Switch1.Debounce();
    __Switch2.Debounce();
    __Encoder1.Debounce();
    __Encoder2.Debounce();
    __Encoder3.Debounce();
    __Encoder0.Debounce();

    // Process real-time GUI updates
    __GUI.RTProcess();

    // Process audio buffer samples
    for (size_t i = 0; i < AUDIO_BUFFER_SIZE; i++) {

        // Apply state change only when input is near silence to avoid clicks
        if ((__OnOffCmd != __MemOnOff) && (fabs(pIn->Right + pIn->Left) < 0.001f)) {
            __MemOnOff = __OnOffCmd;
        }

        // Process audio through GUI and effect chain
        __GUI.GUIProcess(pIn);
        __Effect.Process(pIn, pOut, __MemOnOff);

        // Advance buffer pointers
        pOut++;
        pIn++;
    }

#ifdef MONITOR
    __Monitor.stopMonitoring(); // Stop performance monitoring
#endif
}

// =============================================================================
// Main Application Loop
// =============================================================================

//**********************************************************************************
// MainLoop
// Main application loop (runs in background)
//**********************************************************************************
void MainLoop() {
    uint32_t GUITrigger     = HAL_GetTick();  // GUI update timer
    uint32_t MIDITrigger    = HAL_GetTick();  // MIDI update timer
#ifdef MONITOR
    uint32_t MonitorTrigger = HAL_GetTick();  // Monitor update timer
#endif
    uint32_t GeneralTrigger = HAL_GetTick();  // General system update timer

    while (1) {
        uint32_t CurrentTick = HAL_GetTick();

        // Update GUI at regular intervals
        if ((CurrentTick - GUITrigger) >= GUI_UPDATE_MS) {
            GUITrigger = CurrentTick;
            __GUI.Update();        // Update GUI state
            __Display.flush();     // Refresh display
        }

        // Process MIDI events at regular intervals
        if ((CurrentTick - MIDITrigger) >= MIDI_UPDATE_MS) {
            MIDITrigger = CurrentTick;
            __Midi.ProcessBuffer(); // Process hardware MIDI
            ProcessMidiFifo();      // Process USB MIDI events
        }

        // Update monitor statistics (conditional)
#ifdef MONITOR
        if ((CurrentTick - MonitorTrigger) >= MONITOR_UPDATE_MS) {
            MonitorTrigger = CurrentTick;
            CPULoad    = __Monitor.getCPULoad_percent();     // Get CPU load
            EffectTime = __Monitor.getAverageExecutionTime_us(); // Get effect processing time
            Frequency  = __Monitor.getAverageFrequency_Hz(); // Get operating frequency
            __Monitor.reset(); // Reset monitor counters
        }
#endif

        // General system maintenance
        if ((CurrentTick - GeneralTrigger) >= GENERAL_UPDATE_MS) {
            GeneralTrigger = CurrentTick;

            // Blink LED to confirm audio thread is running
            if (__CT >= (uint32_t)(((float)SAMPLING_RATE / 4.0f) * 0.5f)) {
                __CT = 0;
                HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
            }
        }
    }
}

//***End of file**************************************************************
